#pragma once
#include "md_prsr/optional.hpp"
#include "transcoder/byte_order.hpp"
#include "transcoder/options.hpp"
#include "transcoder/basic_types.hpp"
#include <boost/detail/bitmask.hpp>
#include <variant>
#include <array>
#include <cstdint>


// auto generated by eobi_gen(WIP) from : https://www.eurex.com/resource/blob/4332346/4b66e684ab3cf9e2cee92ca534cd1a68/data/T7_R.13.1_%20EOBI_XML_Representation_Version_2.zip#eobi.xml

namespace eobi { template <typename T, std::uint8_t> using float_decimal = T;}

namespace eobi::v13_1 {

	using BodyLen=md_prsr::optional<std::uint16_t,0xFFFF>;
	using MsgSeqNum=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	struct MessageHeaderComp{
		BodyLen bodyLen;
		std::uint16_t templateID;
		MsgSeqNum msgSeqNum;
	};
	using SecurityID=md_prsr::optional<std::uint64_t,0x8000000000000000>;
	using TransactTime=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	using SecurityDesc=std::array<char,40>;
	using SecuritySubType=md_prsr::optional<std::uint32_t,0x80000000>;
	enum class ProductComplex:std::uint8_t{
		SimpleInstrument=1,// 
		StandardOptionStrategy=2,// 
		NonStandardOptionStrategy=3,// 
		VolatilityStrategy=4,// 
		FuturesSpread=5,// 
		InterProductSpread=6,// 
		StandardFuturesStrategy=7,// 
		PackAndBundle=8,// 
		Strip=9,// 
		FlexibleInstrument=10,// 
		CommodityStrip=11,// 
		ScaledSimpleInstrument=12,// 
		NonStandardVolatilityStrategy=13,// 
		TotalReturnFutureStrategy=14,// 
		NoValue=0xFF
	};
	enum class ImpliedMarketIndicator:std::uint8_t{
		NotImplied=0,// 
		ImpliedInOut=3,// 
		NoValue=0xFF
	};
	using QuantityScalingFactor=md_prsr::optional<std::uint16_t,0xFFFF>;
	using LegRatioMultiplier=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	using NoLegs=md_prsr::optional<std::uint8_t,0xFF>;
	enum class LastFragment:std::uint8_t{
		N=0,// 
		Y=1,// 
		NoValue=0xFF
	};
	using LegSymbol=md_prsr::optional<std::uint32_t,0x80000000>;
	using LegSecurityID=md_prsr::optional<std::uint64_t,0x8000000000000000>;
	using LegPrice=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using LegRatioQty=md_prsr::optional<std::uint32_t,0x80000000>;
	enum class LegSecurityType:std::uint8_t{
		LegSecurityMultiLeg=1,// 
		LegSecurityUnderlyingLeg=2,// 
		NoValue=0xFF
	};
	enum class LegSide:std::uint8_t{
		Buy=1,// 
		Sell=2,// 
		NoValue=0xFF
	};
	enum class RelatedPriceType:std::uint8_t{
		Basis=1,// 
		NoValue=0xFF
	};
	enum class TradingStyle:std::uint8_t{
		Regular=1,// 
		TRF_TAC=2,// 
		TRF_TAM=3,// 
		MOC=4,// 
		NoValue=0xFF
	};
	using RelatedPrice=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	struct InstrmtLegGrpComp{
		LegSymbol legSymbol;
		tc::padding<4> pad4;
		LegSecurityID legSecurityID;
		LegPrice legPrice;
		LegRatioQty legRatioQty;
		md_prsr::optional<LegSecurityType,LegSecurityType::NoValue> legSecurityType;
		md_prsr::optional<LegSide,LegSide::NoValue> legSide;
		md_prsr::optional<RelatedPriceType,RelatedPriceType::NoValue> relatedPriceType;
		md_prsr::optional<TradingStyle,TradingStyle::NoValue> tradingStyle;
		RelatedPrice relatedPrice;
	};
	struct AddComplexInstrument{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
		SecurityDesc securityDesc;
		SecuritySubType securitySubType;
		md_prsr::optional<ProductComplex,ProductComplex::NoValue> productComplex;
		md_prsr::optional<ImpliedMarketIndicator,ImpliedMarketIndicator::NoValue> impliedMarketIndicator;
		QuantityScalingFactor quantityScalingFactor;
		LegRatioMultiplier legRatioMultiplier;
		NoLegs noLegs;
		tc::padding<2> pad2;
		md_prsr::optional<LastFragment,LastFragment::NoValue> lastFragment;
		InstrmtLegGrpComp instrmtLegGrp;
	};
	enum class SecurityType:std::uint8_t{
		OPT=1,// Option
		FUT=2,// Future
		MLEG=3,// Multi-Leg
		NoValue=0xFF
	};
	enum class PutOrCall:std::uint8_t{
		Put=0,// 
		Call=1,// 
		NoValue=0xFF
	};
	enum class ExerciseStyle:std::uint8_t{
		European=0,// 
		American=1,// 
		NoValue=0xFF
	};
	enum class SettlMethod:std::uint8_t{
		Cash=0,// 
		Physical=1,// 
		NoValue=0xFF
	};
	using MaturityDate=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	using StrikePrice=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using OptAttribute=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	using ContractDate=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	using SecurityReferenceDataSupplement=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	struct AddFlexibleInstrument{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
		SecurityDesc securityDesc;
		md_prsr::optional<SecurityType,SecurityType::NoValue> securityType;
		md_prsr::optional<PutOrCall,PutOrCall::NoValue> putOrCall;
		md_prsr::optional<ExerciseStyle,ExerciseStyle::NoValue> exerciseStyle;
		md_prsr::optional<SettlMethod,SettlMethod::NoValue> settlMethod;
		MaturityDate maturityDate;
		StrikePrice strikePrice;
		OptAttribute optAttribute;
		ContractDate contractDate;
		SecurityReferenceDataSupplement securityReferenceDataSupplement;
		tc::padding<4> pad4;
	};
	using RelatedSecurityID=md_prsr::optional<std::uint64_t,0x8000000000000000>;
	struct RelatedInstrumentGrpComp{
		RelatedSecurityID relatedSecurityID;
	};
	struct AddScaledSimpleInstrument{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
		SecurityDesc securityDesc;
		md_prsr::optional<SecurityType,SecurityType::NoValue> securityType;
		tc::padding<1> pad1;
		QuantityScalingFactor quantityScalingFactor;
		tc::padding<4> pad4;
		RelatedInstrumentGrpComp relatedInstrumentGrp;
	};
	using BidPx=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using OfferPx=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using BidSize=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	using OfferSize=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	enum class PotentialSecurityTradingEvent:std::uint8_t{
		None=0,// None
		PriceVolatilityAuctionIsExtended=10,// Price volatility, auction is extended
		NoValue=0xFF
	};
	enum class BidOrdType:std::uint8_t{
		Market=1,// Market Order
		NoValue=0xFF
	};
	enum class OfferOrdType:std::uint8_t{
		Market=1,// Market Order
		NoValue=0xFF
	};
	struct AuctionBBO{
		MessageHeaderComp messageHeader;
		TransactTime transactTime;
		SecurityID securityID;
		BidPx bidPx;
		OfferPx offerPx;
		BidSize bidSize;
		OfferSize offerSize;
		md_prsr::optional<PotentialSecurityTradingEvent,PotentialSecurityTradingEvent::NoValue> potentialSecurityTradingEvent;
		md_prsr::optional<BidOrdType,BidOrdType::NoValue> bidOrdType;
		md_prsr::optional<OfferOrdType,OfferOrdType::NoValue> offerOrdType;
		tc::padding<5> pad5;
	};
	using LastPx=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using LastQty=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	using ImbalanceQty=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	enum class SecurityTradingStatus:std::uint8_t{
		TradingHalt=2,// 
		MarketImbalanceBuy=7,// 
		MarketImbalanceSell=8,// 
		Closed=200,// 
		Restricted=201,// 
		Book=202,// 
		Continuous=203,// 
		OpeningAuction=204,// 
		OpeningAuctionFreeze=205,// 
		IntradayAuction=206,// 
		IntradayAuctionFreeze=207,// 
		CircuitBreakerAuction=208,// 
		CircuitBreakerAuctionFreeze=209,// 
		ClosingAuction=210,// 
		ClosingAuctionFreeze=211,// 
		IPOAuction=212,// 
		IPOAuctionFreeze=213,// 
		PreCall=214,// 
		Call=215,// 
		Freeze=216,// 
		TradeAtClose=217,// 
		CircuitBreakerAuctionTriggeredByStaticLimitBreach=220,// 
		CircuitBreakerAuctionTriggeredByStaticLimitBreachFreeze=221,// 
		NoValue=0xFF
	};
	struct AuctionClearingPrice{
		MessageHeaderComp messageHeader;
		TransactTime transactTime;
		SecurityID securityID;
		LastPx lastPx;
		LastQty lastQty;
		ImbalanceQty imbalanceQty;
		md_prsr::optional<SecurityTradingStatus,SecurityTradingStatus::NoValue> securityTradingStatus;
		md_prsr::optional<PotentialSecurityTradingEvent,PotentialSecurityTradingEvent::NoValue> potentialSecurityTradingEvent;
		tc::padding<6> pad6;
	};
	enum class Side:std::uint8_t{
		Buy=1,// 
		Sell=2,// 
		NoValue=0xFF
	};
	enum class CrossRequestType:std::uint8_t{
		CrossAnnouncement=1,// 
		LiquidityImprovementCross=2,// 
		NoValue=0xFF
	};
	enum class InputSource:std::uint8_t{
		CLIPClientBroker=1,// 
		NoValue=0xFF
	};
	struct CrossRequest{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		LastPx lastPx;
		LastQty lastQty;
		md_prsr::optional<Side,Side::NoValue> side;
		md_prsr::optional<CrossRequestType,CrossRequestType::NoValue> crossRequestType;
		md_prsr::optional<InputSource,InputSource::NoValue> inputSource;
		tc::padding<5> pad5;
		TransactTime transactTime;
	};
	using RequestTime=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	using ExecID=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	enum class AggressorSide:std::uint8_t{
		Buy=1,// Triggered by the buy side
		Sell=2,// Triggered by the sell side
		NoValue=0xFF
	};
	enum class TradeCondition:std::uint16_t{
		ImpliedTrade=1,// 
		OutOfSequence=107,// Out of sequence (k)
		MidpointPrice=155,// Midpoint Price (BB)
		TradingOnTermsOfIssue=156,// Trading On Terms Of Issue (BC)
		SpecialAuction=596,// Special Auction (SA)
		TradeAtClose=624,// Trade At Close (TC)
		Retail=743,// Retail (XR)
		NoValue=0xFFFF
	};
	using TradingHHIIndicator=md_prsr::optional<std::uint8_t,0xFF>;
	using TrdRegTSPrevTimePriority=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	using DisplayQty=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	using Price=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	struct RemainingOrderDetailsComp{
		TrdRegTSPrevTimePriority trdRegTSPrevTimePriority;
		DisplayQty displayQty;
		Price price;
	};
	using RestingHiddenQty=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	using RestingCxlQty=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	using AggressorTime=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	struct ExecutionSummary{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		RequestTime requestTime;
		ExecID execID;
		LastQty lastQty;
		md_prsr::optional<AggressorSide,AggressorSide::NoValue> aggressorSide;
		tc::padding<1> pad1;
		md_prsr::optional<TradeCondition,TradeCondition::NoValue> tradeCondition;
		TradingHHIIndicator tradingHHIIndicator;
		tc::padding<3> pad3;
		LastPx lastPx;
		RemainingOrderDetailsComp remainingOrderDetails;
		RestingHiddenQty restingHiddenQty;
		RestingCxlQty restingCxlQty;
		AggressorTime aggressorTime;
	};
	enum class OrdType:std::uint8_t{
		Market=1,// Market Order
		NoValue=0xFF
	};
	enum class AlgorithmicTradeIndicator:std::uint8_t{
		AlgorithmicTrade=1,// 
		NoValue=0xFF
	};
	enum class HHIIndicator:std::uint8_t{
        NoUpdate = std::uint8_t(-1),
		NoValue=0x80
	};
	using TrdMatchID=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	using TrdRegTSTimePriority=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	struct FullOrderExecution{
		MessageHeaderComp messageHeader;
		md_prsr::optional<Side,Side::NoValue> side;
		md_prsr::optional<OrdType,OrdType::NoValue> ordType;
		md_prsr::optional<AlgorithmicTradeIndicator,AlgorithmicTradeIndicator::NoValue> algorithmicTradeIndicator;
		md_prsr::optional<HHIIndicator,HHIIndicator::NoValue> hHIIndicator;
		TrdMatchID trdMatchID;
		Price price;
		TrdRegTSTimePriority trdRegTSTimePriority;
		SecurityID securityID;
		LastQty lastQty;
		LastPx lastPx;
	};
	using LastMsgSeqNumProcessed=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	struct Heartbeat{
		MessageHeaderComp messageHeader;
		LastMsgSeqNumProcessed lastMsgSeqNumProcessed;
		tc::padding<4> pad4;
	};
	enum class SecurityStatus:std::uint8_t{
		Active=1,// 
		Inactive=2,// 
		Expired=4,// 
		KnockedOut=6,// 
		KnockOutRevoked=7,// 
		Suspended=9,// 
		PendingDeletion=11,// 
		KnockedOutAndSuspended=12,// 
		NoValue=0xFF
	};
	enum class MarketCondition:std::uint8_t{
		Normal=0,// 
		Stressed=1,// 
		NoValue=0xFF
	};
	enum class FastMarketIndicator:std::uint8_t{
		No=0,// 
		Yes=1,// 
		NoValue=0xFF
	};
	enum class SecurityTradingEvent:std::uint8_t{
		PriceVolatilityAuctionIsExtended=10,// Price volatility, auction is extended
		PriceVolatilityAuctionIsExtendedAgain=11,// Price volatility, auction is extended again
		NoValue=0xFF
	};
	enum class SoldOutIndicator:std::uint8_t{
		SoldOut=1,// 
		NoValue=0xFF
	};
	using HighPx=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using LowPx=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	enum class TESSecurityStatus:std::uint8_t{
		Active=1,// 
		Inactive=2,// 
		Expired=4,// 
		Suspended=9,// 
		NoValue=0xFF
	};
	struct InstrumentStateChange{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		md_prsr::optional<SecurityStatus,SecurityStatus::NoValue> securityStatus;
		md_prsr::optional<SecurityTradingStatus,SecurityTradingStatus::NoValue> securityTradingStatus;
		md_prsr::optional<MarketCondition,MarketCondition::NoValue> marketCondition;
		md_prsr::optional<FastMarketIndicator,FastMarketIndicator::NoValue> fastMarketIndicator;
		md_prsr::optional<SecurityTradingEvent,SecurityTradingEvent::NoValue> securityTradingEvent;
		md_prsr::optional<SoldOutIndicator,SoldOutIndicator::NoValue> soldOutIndicator;
		tc::padding<2> pad2;
		HighPx highPx;
		LowPx lowPx;
		TransactTime transactTime;
		md_prsr::optional<TESSecurityStatus,TESSecurityStatus::NoValue> tESSecurityStatus;
		tc::padding<7> pad7;
	};
	using LastUpdateTime=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	using TrdRegTSExecutionTime=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	using TotNoOrders=md_prsr::optional<std::uint16_t,0xFFFF>;
	using NoMDEntries=md_prsr::optional<std::uint8_t,0xFF>;
	using MDEntryPx=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using MDEntrySize=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	enum class MDOriginType:std::uint8_t{
		Book=0,// 
		OffBook=1,// 
		NoValue=0xFF
	};
	enum class MDEntryType:std::uint8_t{
		Trade=2,// 
		OpeningPrice=4,// 
		ClosingPrice=5,// 
		HighPrice=7,// 
		LowPrice=8,// 
		TradeVolume=66,// 
		PreviousClosingPrice=101,// 
		OpeningAuction=200,// 
		IntradayAuction=201,// 
		CircuitBreakerAuction=202,// 
		ClosingAuction=203,// 
		IPOAuction=204,// 
		NoValue=0xFF
	};
	enum class TrdType:std::uint16_t{
		BlockTrade=1,// 
		EFP=2,// Exchange For Physical
		EFS=12,// Exchange For Swap
		OTC=54,// 
		ExchangeBasisFacility=55,// ExchangeBasisFacility
		VolaTrade=1000,// 
		EFPFinTrade=1001,// EFP-Fin Trade
		EFPIndexFuturesTrade=1002,// EFP-Index-Futures Trade
		BlockTradeAtMarket=1004,// Block Trade At Market
		XetraEurexEnlightTriggeredTrade=1006,// Xetra / Eurex Enlight Triggered Trade
		BlockQTPIPTrade=1007,// Block QTPIP Trade
		DeltaTradeAtMarket=1017,// Delta Trade At Market
		NoValue=0xFFFF
	};
	enum class MultiLegReportingType:std::uint8_t{
		SingleSecurity=1,// 
		IndividualLegOfAMultiLegSecurity=2,// 
		MultiLegSecurity=3,// 
		NoValue=0xFF
	};
	enum class MultiLegPriceModel:std::uint8_t{
		Standard=0,// 
		UserDefined=1,// 
		NoValue=0xFF
	};
	using NonDisclosedTradeVolume=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	struct MDInstrumentEntryGrpComp{
		MDEntryPx mDEntryPx;
		MDEntrySize mDEntrySize;
		md_prsr::optional<MDOriginType,MDOriginType::NoValue> mDOriginType;
		md_prsr::optional<MDEntryType,MDEntryType::NoValue> mDEntryType;
		md_prsr::optional<TradeCondition,TradeCondition::NoValue> tradeCondition;
		md_prsr::optional<TrdType,TrdType::NoValue> trdType;
		md_prsr::optional<MultiLegReportingType,MultiLegReportingType::NoValue> multiLegReportingType;
		md_prsr::optional<MultiLegPriceModel,MultiLegPriceModel::NoValue> multiLegPriceModel;
		NonDisclosedTradeVolume nonDisclosedTradeVolume;
	};
	struct InstrumentSummary{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		LastUpdateTime lastUpdateTime;
		TrdRegTSExecutionTime trdRegTSExecutionTime;
		TotNoOrders totNoOrders;
		md_prsr::optional<SecurityStatus,SecurityStatus::NoValue> securityStatus;
		md_prsr::optional<SecurityTradingStatus,SecurityTradingStatus::NoValue> securityTradingStatus;
		md_prsr::optional<MarketCondition,MarketCondition::NoValue> marketCondition;
		md_prsr::optional<FastMarketIndicator,FastMarketIndicator::NoValue> fastMarketIndicator;
		md_prsr::optional<SecurityTradingEvent,SecurityTradingEvent::NoValue> securityTradingEvent;
		md_prsr::optional<SoldOutIndicator,SoldOutIndicator::NoValue> soldOutIndicator;
		HighPx highPx;
		LowPx lowPx;
		md_prsr::optional<ProductComplex,ProductComplex::NoValue> productComplex;
		NoMDEntries noMDEntries;
		md_prsr::optional<TESSecurityStatus,TESSecurityStatus::NoValue> tESSecurityStatus;
		tc::padding<5> pad5;
		MDInstrumentEntryGrpComp mDInstrumentEntryGrp;
	};
	struct MDTradeEntryGrpComp{
		MDEntryPx mDEntryPx;
		MDEntrySize mDEntrySize;
		md_prsr::optional<MDEntryType,MDEntryType::NoValue> mDEntryType;
		tc::padding<7> pad7;
	};
	enum class InstrumentScopeProductComplex:std::uint8_t{
		SimpleInstrument=1,// 
		StandardOptionStrategy=2,// 
		NonStandardOptionStrategy=3,// 
		VolatilityStrategy=4,// 
		FuturesSpread=5,// 
		InterProductSpread=6,// 
		StandardFuturesStrategy=7,// 
		PackAndBundle=8,// 
		Strip=9,// 
		FlexibleInstrument=10,// 
		CommodityStrip=11,// 
		ScaledSimpleInstrument=12,// 
		NonStandardVolatilityStrategy=13,// 
		TotalReturnFutureStrategy=14,// 
		NoValue=0xFF
	};
	enum class SecurityMassStatus:std::uint8_t{
		Active=1,// 
		Inactive=2,// 
		Expired=4,// 
		KnockedOut=6,// 
		KnockOutRevoked=7,// 
		Suspended=9,// 
		PendingDeletion=11,// 
		KnockedOutAndSuspended=12,// 
		NoValue=0xFF
	};
	enum class SecurityMassTradingStatus:std::uint8_t{
		TradingHalt=2,// 
		MarketImbalanceBuy=7,// 
		MarketImbalanceSell=8,// 
		Closed=200,// 
		Restricted=201,// 
		Book=202,// 
		Continuous=203,// 
		OpeningAuction=204,// 
		OpeningAuctionFreeze=205,// 
		IntradayAuction=206,// 
		IntradayAuctionFreeze=207,// 
		CircuitBreakerAuction=208,// 
		CircuitBreakerAuctionFreeze=209,// 
		ClosingAuction=210,// 
		ClosingAuctionFreeze=211,// 
		IPOAuction=212,// 
		IPOAuctionFreeze=213,// 
		PreCall=214,// 
		Call=215,// 
		Freeze=216,// 
		TradeAtClose=217,// 
		CircuitBreakerAuctionTriggeredByStaticLimitBreach=220,// 
		CircuitBreakerAuctionTriggeredByStaticLimitBreachFreeze=221,// 
		NoValue=0xFF
	};
	enum class MassMarketCondition:std::uint8_t{
		Normal=0,// 
		Stressed=1,// 
		NoValue=0xFF
	};
	enum class SecurityMassTradingEvent:std::uint8_t{
		PriceVolatilityAuctionIsExtended=10,// Price volatility, auction is extended
		PriceVolatilityAuctionIsExtendedAgain=11,// Price volatility, auction is extended again
		NoValue=0xFF
	};
	enum class MassSoldOutIndicator:std::uint8_t{
		SoldOut=1,// 
		NoValue=0xFF
	};
	enum class TESSecurityMassStatus:std::uint8_t{
		Active=1,// 
		Inactive=2,// 
		Expired=4,// 
		Suspended=9,// 
		NoValue=0xFF
	};
	using NoRelatedSym=md_prsr::optional<std::uint8_t,0xFF>;
	struct SecMassStatGrpComp{
		SecurityID securityID;
		HighPx highPx;
		LowPx lowPx;
		md_prsr::optional<SecurityStatus,SecurityStatus::NoValue> securityStatus;
		md_prsr::optional<SecurityTradingStatus,SecurityTradingStatus::NoValue> securityTradingStatus;
		md_prsr::optional<MarketCondition,MarketCondition::NoValue> marketCondition;
		md_prsr::optional<SecurityTradingEvent,SecurityTradingEvent::NoValue> securityTradingEvent;
		md_prsr::optional<SoldOutIndicator,SoldOutIndicator::NoValue> soldOutIndicator;
		md_prsr::optional<TESSecurityStatus,TESSecurityStatus::NoValue> tESSecurityStatus;
		tc::padding<2> pad2;
	};
	struct MassInstrumentStateChange{
		MessageHeaderComp messageHeader;
		md_prsr::optional<InstrumentScopeProductComplex,InstrumentScopeProductComplex::NoValue> instrumentScopeProductComplex;
		md_prsr::optional<SecurityMassStatus,SecurityMassStatus::NoValue> securityMassStatus;
		md_prsr::optional<SecurityMassTradingStatus,SecurityMassTradingStatus::NoValue> securityMassTradingStatus;
		md_prsr::optional<MassMarketCondition,MassMarketCondition::NoValue> massMarketCondition;
		md_prsr::optional<FastMarketIndicator,FastMarketIndicator::NoValue> fastMarketIndicator;
		md_prsr::optional<SecurityMassTradingEvent,SecurityMassTradingEvent::NoValue> securityMassTradingEvent;
		md_prsr::optional<MassSoldOutIndicator,MassSoldOutIndicator::NoValue> massSoldOutIndicator;
		md_prsr::optional<TESSecurityMassStatus,TESSecurityMassStatus::NoValue> tESSecurityMassStatus;
		TransactTime transactTime;
		md_prsr::optional<LastFragment,LastFragment::NoValue> lastFragment;
		NoRelatedSym noRelatedSym;
		tc::padding<6> pad6;
		SecMassStatGrpComp secMassStatGrp;
	};
	struct OrderDetailsComp{
		TrdRegTSTimePriority trdRegTSTimePriority;
		DisplayQty displayQty;
		md_prsr::optional<Side,Side::NoValue> side;
		md_prsr::optional<OrdType,OrdType::NoValue> ordType;
		md_prsr::optional<HHIIndicator,HHIIndicator::NoValue> hHIIndicator;
		tc::padding<5> pad5;
		Price price;
	};
	struct OrderAdd{
		MessageHeaderComp messageHeader;
		RequestTime requestTime;
		SecurityID securityID;
		OrderDetailsComp orderDetails;
	};
	struct OrderDelete{
		MessageHeaderComp messageHeader;
		RequestTime requestTime;
		TransactTime transactTime;
		SecurityID securityID;
		OrderDetailsComp orderDetails;
	};
	struct OrderMassDelete{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
	};
	using PrevPrice=md_prsr::optional<eobi::float_decimal<std::uint64_t,8>,0x8000000000000000ULL>;
	using PrevDisplayQty=md_prsr::optional<eobi::float_decimal<std::uint64_t,4>,0x8000000000000000ULL>;
	enum class PrevPriceHHIIndicator:std::uint8_t{
        NoUpdate = std::uint8_t(-1),
		NoValue=0x80
	};
	struct OrderModify{
		MessageHeaderComp messageHeader;
		RequestTime requestTime;
		TrdRegTSPrevTimePriority trdRegTSPrevTimePriority;
		PrevPrice prevPrice;
		PrevDisplayQty prevDisplayQty;
		SecurityID securityID;
		OrderDetailsComp orderDetails;
		md_prsr::optional<PrevPriceHHIIndicator,PrevPriceHHIIndicator::NoValue> prevPriceHHIIndicator;
		tc::padding<7> pad7;
	};
	struct OrderModifySamePrio{
		MessageHeaderComp messageHeader;
		RequestTime requestTime;
		TransactTime transactTime;
		PrevDisplayQty prevDisplayQty;
		SecurityID securityID;
		OrderDetailsComp orderDetails;
	};
	using ApplSeqNum=md_prsr::optional<std::uint32_t,0xFFFFFFFF>;
	using MarketSegmentID=md_prsr::optional<std::uint32_t,0x80000000>;
	using PartitionID=md_prsr::optional<std::uint8_t,0xFF>;
	enum class CompletionIndicator:std::uint8_t{
		Incomplete=0,// 
		Complete=1,// 
		NoValue=0xFF
	};
	enum class ApplSeqResetIndicator:std::uint8_t{
		NoReset=0,// No Reset
		Reset=1,// Reset
		NoValue=0xFF
	};
	using DSCP=md_prsr::optional<std::uint8_t,0xFF>;
	struct PacketHeader{
		MessageHeaderComp messageHeader;
		ApplSeqNum applSeqNum;
		MarketSegmentID marketSegmentID;
		PartitionID partitionID;
		md_prsr::optional<CompletionIndicator,CompletionIndicator::NoValue> completionIndicator;
		md_prsr::optional<ApplSeqResetIndicator,ApplSeqResetIndicator::NoValue> applSeqResetIndicator;
		DSCP dSCP;
		tc::padding<4> pad4;
		TransactTime transactTime;
	};
	struct PartialOrderExecution{
		MessageHeaderComp messageHeader;
		md_prsr::optional<Side,Side::NoValue> side;
		md_prsr::optional<OrdType,OrdType::NoValue> ordType;
		md_prsr::optional<AlgorithmicTradeIndicator,AlgorithmicTradeIndicator::NoValue> algorithmicTradeIndicator;
		md_prsr::optional<HHIIndicator,HHIIndicator::NoValue> hHIIndicator;
		TrdMatchID trdMatchID;
		Price price;
		TrdRegTSTimePriority trdRegTSTimePriority;
		SecurityID securityID;
		LastQty lastQty;
		LastPx lastPx;
	};
	enum class TradingSessionID:std::uint8_t{
		Day=1,// 
		Morning=3,// 
		Evening=5,// 
		AfterHours=6,// 
		Holiday=7,// 
		NoValue=0xFF
	};
	enum class TradingSessionSubID:std::uint8_t{
		PreTrading=1,// 
		Continuous=3,// 
		Closing=4,// 
		PostTrading=5,// 
		Quiescent=7,// 
		NoValue=0xFF
	};
	enum class TradSesStatus:std::uint8_t{
		Halted=1,// 
		Open=2,// 
		Closed=3,// 
		NoValue=0xFF
	};
	enum class TESTradSesStatus:std::uint8_t{
		Halted=1,// 
		Open=2,// 
		Closed=3,// 
		PreClose=5,// 
		NoValue=0xFF
	};
	struct ProductStateChange{
		MessageHeaderComp messageHeader;
		md_prsr::optional<TradingSessionID,TradingSessionID::NoValue> tradingSessionID;
		md_prsr::optional<TradingSessionSubID,TradingSessionSubID::NoValue> tradingSessionSubID;
		md_prsr::optional<TradSesStatus,TradSesStatus::NoValue> tradSesStatus;
		md_prsr::optional<MarketCondition,MarketCondition::NoValue> marketCondition;
		md_prsr::optional<FastMarketIndicator,FastMarketIndicator::NoValue> fastMarketIndicator;
		md_prsr::optional<TESTradSesStatus,TESTradSesStatus::NoValue> tESTradSesStatus;
		tc::padding<2> pad2;
		TransactTime transactTime;
	};
	struct ProductSummary{
		MessageHeaderComp messageHeader;
		LastMsgSeqNumProcessed lastMsgSeqNumProcessed;
		md_prsr::optional<TradingSessionID,TradingSessionID::NoValue> tradingSessionID;
		md_prsr::optional<TradingSessionSubID,TradingSessionSubID::NoValue> tradingSessionSubID;
		md_prsr::optional<TradSesStatus,TradSesStatus::NoValue> tradSesStatus;
		md_prsr::optional<MarketCondition,MarketCondition::NoValue> marketCondition;
		md_prsr::optional<FastMarketIndicator,FastMarketIndicator::NoValue> fastMarketIndicator;
		md_prsr::optional<TESTradSesStatus,TESTradSesStatus::NoValue> tESTradSesStatus;
		tc::padding<6> pad6;
	};
	struct QuoteRequest{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		LastQty lastQty;
		md_prsr::optional<Side,Side::NoValue> side;
		tc::padding<7> pad7;
		TransactTime transactTime;
	};
	struct SnapshotOrder{
		MessageHeaderComp messageHeader;
		OrderDetailsComp orderDetails;
	};
	using TransBkdTime=md_prsr::optional<std::uint64_t,0xFFFFFFFFFFFFFFFF>;
	using NumberOfBuySides=md_prsr::optional<std::uint16_t,0xFFFF>;
	using NumberOfSellSides=md_prsr::optional<std::uint16_t,0xFFFF>;
	struct TESTradeReport{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
		LastQty lastQty;
		LastPx lastPx;
		TrdMatchID trdMatchID;
		md_prsr::optional<TrdType,TrdType::NoValue> trdType;
		md_prsr::optional<TradeCondition,TradeCondition::NoValue> tradeCondition;
		md_prsr::optional<MultiLegReportingType,MultiLegReportingType::NoValue> multiLegReportingType;
		md_prsr::optional<MultiLegPriceModel,MultiLegPriceModel::NoValue> multiLegPriceModel;
		tc::padding<6> pad6;
		NonDisclosedTradeVolume nonDisclosedTradeVolume;
		TransBkdTime transBkdTime;
		NumberOfBuySides numberOfBuySides;
		NumberOfSellSides numberOfSellSides;
		tc::padding<4> pad4;
	};
	using NumberOfBuyOrders=md_prsr::optional<std::uint16_t,0xFFFF>;
	using NumberOfSellOrders=md_prsr::optional<std::uint16_t,0xFFFF>;
	struct TopOfBook{
		MessageHeaderComp messageHeader;
		TransactTime transactTime;
		SecurityID securityID;
		BidPx bidPx;
		OfferPx offerPx;
		BidSize bidSize;
		OfferSize offerSize;
		NumberOfBuyOrders numberOfBuyOrders;
		NumberOfSellOrders numberOfSellOrders;
		tc::padding<4> pad4;
	};
	enum class MatchType:std::uint8_t{
		ConfirmedTradeReport=3,// Manual Trade Entry
		CrossAuction=5,// Trade from Uncrossing
		CallAuction=7,// Trade from Auction
		LiquidityImprovementCross=13,// Trade from Liquidity Improvement Cross
		ContinuousAuction=14,// Price Without Turnover in Continuous Auction
		NoValue=0xFF
	};
	enum class MatchSubType:std::uint8_t{
		OpeningAuction=1,// 
		ClosingAuction=2,// 
		IntradayAuction=3,// 
		CircuitBreakerAuction=4,// 
		IPOAuction=5,// 
		NoValue=0xFF
	};
	struct TradeReport{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
		LastQty lastQty;
		LastPx lastPx;
		TrdMatchID trdMatchID;
		md_prsr::optional<MatchType,MatchType::NoValue> matchType;
		md_prsr::optional<MatchSubType,MatchSubType::NoValue> matchSubType;
		md_prsr::optional<AlgorithmicTradeIndicator,AlgorithmicTradeIndicator::NoValue> algorithmicTradeIndicator;
		tc::padding<1> pad1;
		md_prsr::optional<TradeCondition,TradeCondition::NoValue> tradeCondition;
		tc::padding<6> pad6;
	};
	struct TradeReversal{
		MessageHeaderComp messageHeader;
		SecurityID securityID;
		TransactTime transactTime;
		LastQty lastQty;
		LastPx lastPx;
		TrdRegTSExecutionTime trdRegTSExecutionTime;
		TrdMatchID trdMatchID;
		md_prsr::optional<TradeCondition,TradeCondition::NoValue> tradeCondition;
		md_prsr::optional<MDOriginType,MDOriginType::NoValue> mDOriginType;
		NoMDEntries noMDEntries;
		MDTradeEntryGrpComp mDTradeEntryGrp;
	};

tc::options<tc::flag::little_endian> protocol_options(...);

using messages = std::variant<
	AddComplexInstrument,
	AddFlexibleInstrument,
	InstrumentSummary,
	AddScaledSimpleInstrument,
	PartialOrderExecution,
	AuctionBBO,
	FullOrderExecution,
	TradeReversal,
	AuctionClearingPrice,
	CrossRequest,
	ExecutionSummary,
	Heartbeat,
	InstrumentStateChange,
	MassInstrumentStateChange,
	OrderAdd,
	OrderDelete,
	OrderMassDelete,
	TopOfBook,
	OrderModify,
	OrderModifySamePrio,
	ProductSummary,
	PacketHeader,
	SnapshotOrder,
	ProductStateChange,
	QuoteRequest,
	TESTradeReport,
	TradeReport
>;


} // namespace eobi::v13_1

 template <> struct tc::type_id<eobi::v13_1::messages> { using type = tc::proto_type_id<&eobi::v13_1::MessageHeaderComp::templateID>;}; 

template<> struct tc::type_id<eobi::v13_1::AddComplexInstrument> { constexpr std::uint16_t operator()() const noexcept { return 13400;} };
template<> struct tc::type_id<eobi::v13_1::AddFlexibleInstrument> { constexpr std::uint16_t operator()() const noexcept { return 13401;} };
template<> struct tc::type_id<eobi::v13_1::InstrumentSummary> { constexpr std::uint16_t operator()() const noexcept { return 13601;} };
template<> struct tc::type_id<eobi::v13_1::AddScaledSimpleInstrument> { constexpr std::uint16_t operator()() const noexcept { return 13402;} };
template<> struct tc::type_id<eobi::v13_1::PartialOrderExecution> { constexpr std::uint16_t operator()() const noexcept { return 13105;} };
template<> struct tc::type_id<eobi::v13_1::AuctionBBO> { constexpr std::uint16_t operator()() const noexcept { return 13500;} };
template<> struct tc::type_id<eobi::v13_1::FullOrderExecution> { constexpr std::uint16_t operator()() const noexcept { return 13104;} };
template<> struct tc::type_id<eobi::v13_1::TradeReversal> { constexpr std::uint16_t operator()() const noexcept { return 13200;} };
template<> struct tc::type_id<eobi::v13_1::AuctionClearingPrice> { constexpr std::uint16_t operator()() const noexcept { return 13501;} };
template<> struct tc::type_id<eobi::v13_1::CrossRequest> { constexpr std::uint16_t operator()() const noexcept { return 13502;} };
template<> struct tc::type_id<eobi::v13_1::ExecutionSummary> { constexpr std::uint16_t operator()() const noexcept { return 13202;} };
template<> struct tc::type_id<eobi::v13_1::Heartbeat> { constexpr std::uint16_t operator()() const noexcept { return 13001;} };
template<> struct tc::type_id<eobi::v13_1::InstrumentStateChange> { constexpr std::uint16_t operator()() const noexcept { return 13301;} };
template<> struct tc::type_id<eobi::v13_1::MassInstrumentStateChange> { constexpr std::uint16_t operator()() const noexcept { return 13302;} };
template<> struct tc::type_id<eobi::v13_1::OrderAdd> { constexpr std::uint16_t operator()() const noexcept { return 13100;} };
template<> struct tc::type_id<eobi::v13_1::OrderDelete> { constexpr std::uint16_t operator()() const noexcept { return 13102;} };
template<> struct tc::type_id<eobi::v13_1::OrderMassDelete> { constexpr std::uint16_t operator()() const noexcept { return 13103;} };
template<> struct tc::type_id<eobi::v13_1::TopOfBook> { constexpr std::uint16_t operator()() const noexcept { return 13504;} };
template<> struct tc::type_id<eobi::v13_1::OrderModify> { constexpr std::uint16_t operator()() const noexcept { return 13101;} };
template<> struct tc::type_id<eobi::v13_1::OrderModifySamePrio> { constexpr std::uint16_t operator()() const noexcept { return 13106;} };
template<> struct tc::type_id<eobi::v13_1::ProductSummary> { constexpr std::uint16_t operator()() const noexcept { return 13600;} };
template<> struct tc::type_id<eobi::v13_1::PacketHeader> { constexpr std::uint16_t operator()() const noexcept { return 13005;} };
template<> struct tc::type_id<eobi::v13_1::SnapshotOrder> { constexpr std::uint16_t operator()() const noexcept { return 13602;} };
template<> struct tc::type_id<eobi::v13_1::ProductStateChange> { constexpr std::uint16_t operator()() const noexcept { return 13300;} };
template<> struct tc::type_id<eobi::v13_1::QuoteRequest> { constexpr std::uint16_t operator()() const noexcept { return 13503;} };
template<> struct tc::type_id<eobi::v13_1::TESTradeReport> { constexpr std::uint16_t operator()() const noexcept { return 13203;} };
template<> struct tc::type_id<eobi::v13_1::TradeReport> { constexpr std::uint16_t operator()() const noexcept { return 13201;} };
